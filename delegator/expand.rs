#![feature(prelude_import)]

#[prelude_import]
use std::prelude::rust_2021::*;

#[macro_use]
extern crate std;

mod delegator {
    impl ::ink::traits::ContractEnv for Delegator {
        type Env = ::ink::env::DefaultEnvironment;
    }

    type Environment = <Delegator as ::ink::traits::ContractEnv>::Env;
    type AccountId = <<Delegator as ::ink::traits::ContractEnv>::Env as ::ink::env::Environment>::AccountId;
    type Balance = <<Delegator as ::ink::traits::ContractEnv>::Env as ::ink::env::Environment>::Balance;
    type Hash = <<Delegator as ::ink::traits::ContractEnv>::Env as ::ink::env::Environment>::Hash;
    type Timestamp = <<Delegator as ::ink::traits::ContractEnv>::Env as ::ink::env::Environment>::Timestamp;
    type BlockNumber = <<Delegator as ::ink::traits::ContractEnv>::Env as ::ink::env::Environment>::BlockNumber;

    const _: () = {
        struct Check {
            salt: (),
            field_0: Which,
            field_1: AccumulatorRef,
        }
    };

    /// Delegates calls to an `adder` or `subber` contract to mutate
    /// a value in an `accumulator` contract.
    ///
    /// # Note
    ///
    /// In order to instantiate the `delegator` smart contract we first
    /// have to manually put the code of the `accumulator`, `adder`
    /// and `subber` smart contracts, receive their code hashes from
    /// the signalled events and put their code hash into our
    /// `delegator` smart contract.
    ///
    /// The `AccumulatorRef`, `AdderRef` and `SubberRef` are smart contract
    /// reference types that have been automatically generated by ink!.
    #[cfg(not(feature = "__ink_dylint_Storage"))]
    pub struct Delegator {
        /// Says which of `adder` or `subber` is currently in use.
        which: <Which as ::ink::storage::traits::AutoStorableHint<
            ::ink::storage::traits::ManualKey<3755538685u32, ()>,
        >>::Type,
        /// The `accumulator` smart contract.
        accumulator: <AccumulatorRef as ::ink::storage::traits::AutoStorableHint<
            ::ink::storage::traits::ManualKey<1027060487u32, ()>,
        >>::Type,
    }

    const _: () = {
        impl<
            __ink_generic_salt: ::ink::storage::traits::StorageKey,
        > ::ink::storage::traits::StorableHint<__ink_generic_salt> for Delegator {
            type Type = Delegator;
            type PreferredKey = ::ink::storage::traits::AutoKey;
        }
    };
    const _: () = {
        impl ::ink::storage::traits::StorageKey for Delegator {
            const KEY: ::ink::primitives::Key = <() as ::ink::storage::traits::StorageKey>::KEY;
        }
    };
    const _: () = {
        impl ::ink::storage::traits::Storable for Delegator {
            #[inline(always)]
            #[allow(non_camel_case_types)]
            fn decode<__ink_I: ::scale::Input>(
                __input: &mut __ink_I,
            ) -> ::core::result::Result<Self, ::scale::Error> {
                ::core::result::Result::Ok(Delegator {
                    which: <<Which as ::ink::storage::traits::AutoStorableHint<
                        ::ink::storage::traits::ManualKey<3755538685u32, ()>,
                    >>::Type as ::ink::storage::traits::Storable>::decode(__input)?,
                    accumulator: <<AccumulatorRef as ::ink::storage::traits::AutoStorableHint<
                        ::ink::storage::traits::ManualKey<1027060487u32, ()>,
                    >>::Type as ::ink::storage::traits::Storable>::decode(__input)?,
                })
            }
            #[inline(always)]
            #[allow(non_camel_case_types)]
            fn encode<__ink_O: ::scale::Output + ?::core::marker::Sized>(
                &self,
                __dest: &mut __ink_O,
            ) {
                match self {
                    Delegator { which: __binding_0, accumulator: __binding_1 } => {
                        {
                            ::ink::storage::traits::Storable::encode(
                                __binding_0,
                                __dest,
                            );
                        }
                        {
                            ::ink::storage::traits::Storable::encode(
                                __binding_1,
                                __dest,
                            );
                        }
                    }
                }
            }
        }
    };
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        impl ::scale_info::TypeInfo for Delegator {
            type Identity = Self;
            fn type_info() -> ::scale_info::Type {
                ::scale_info::Type::builder()
                    .path(::scale_info::Path::new("Delegator", "delegator::delegator"))
                    .type_params(::alloc::vec::Vec::new())
                    .docs(
                        &[
                            "Delegates calls to an `adder` or `subber` contract to mutate",
                            "a value in an `accumulator` contract.",
                            "",
                            "# Note",
                            "",
                            "In order to instantiate the `delegator` smart contract we first",
                            "have to manually put the code of the `accumulator`, `adder`",
                            "and `subber` smart contracts, receive their code hashes from",
                            "the signalled events and put their code hash into our",
                            "`delegator` smart contract.",
                            "",
                            "The `AccumulatorRef`, `AdderRef` and `SubberRef` are smart contract",
                            "reference types that have been automatically generated by ink!.",
                        ],
                    )
                    .composite(
                        ::scale_info::build::Fields::named()
                            .field(|f| {
                                f
                                    .ty::<
                                        <Which as ::ink::storage::traits::AutoStorableHint<
                                            ::ink::storage::traits::ManualKey<3755538685u32, ()>,
                                        >>::Type,
                                    >()
                                    .name("which")
                                    .type_name(
                                        "<Which as::ink::storage::traits::AutoStorableHint<::ink::storage\n::traits::ManualKey<3755538685u32, ()>,>>::Type",
                                    )
                                    .docs(
                                        &["Says which of `adder` or `subber` is currently in use."],
                                    )
                            })
                            .field(|f| {
                                f
                                    .ty::<
                                        <AccumulatorRef as ::ink::storage::traits::AutoStorableHint<
                                            ::ink::storage::traits::ManualKey<1027060487u32, ()>,
                                        >>::Type,
                                    >()
                                    .name("accumulator")
                                    .type_name(
                                        "<AccumulatorRef as::ink::storage::traits::AutoStorableHint<::ink\n::storage::traits::ManualKey<1027060487u32, ()>,>>::Type",
                                    )
                                    .docs(&["The `accumulator` smart contract."])
                            }),
                    )
            }
        }
    };
    const _: () = {
        impl ::ink::storage::traits::StorageLayout for Delegator {
            fn layout(
                __key: &::ink::primitives::Key,
            ) -> ::ink::metadata::layout::Layout {
                ::ink::metadata::layout::Layout::Struct(
                    ::ink::metadata::layout::StructLayout::new(
                        "Delegator",
                        [
                            ::ink::metadata::layout::FieldLayout::new(
                                "which",
                                <<Which as ::ink::storage::traits::AutoStorableHint<
                                    ::ink::storage::traits::ManualKey<3755538685u32, ()>,
                                >>::Type as ::ink::storage::traits::StorageLayout>::layout(
                                    __key,
                                ),
                            ),
                            ::ink::metadata::layout::FieldLayout::new(
                                "accumulator",
                                <<AccumulatorRef as ::ink::storage::traits::AutoStorableHint<
                                    ::ink::storage::traits::ManualKey<1027060487u32, ()>,
                                >>::Type as ::ink::storage::traits::StorageLayout>::layout(
                                    __key,
                                ),
                            ),
                        ],
                    ),
                )
            }
        }
    };
    const _: () = {
        impl ::ink::traits::ContractName for Delegator {
            const NAME: &'static str = "Delegator";
        }
    };
    const _: () = {
        impl<'a> ::ink::codegen::Env for &'a Delegator {
            type EnvAccess = ::ink::EnvAccess<
                'a,
                <Delegator as ::ink::traits::ContractEnv>::Env,
            >;
            fn env(self) -> Self::EnvAccess {
                <<Self as ::ink::codegen::Env>::EnvAccess as ::core::default::Default>::default()
            }
        }
        impl<'a> ::ink::codegen::StaticEnv for Delegator {
            type EnvAccess = ::ink::EnvAccess<
                'static,
                <Delegator as ::ink::traits::ContractEnv>::Env,
            >;
            fn env() -> Self::EnvAccess {
                <<Self as ::ink::codegen::StaticEnv>::EnvAccess as ::core::default::Default>::default()
            }
        }
    };
    const _: () = {
        #[allow(unused_imports)]
        use ::ink::codegen::{Env as _, StaticEnv as _};
    };

    impl ::ink::traits::ContractAmountDispatchables for Delegator {
        const MESSAGES: ::core::primitive::usize = 3usize;
        const CONSTRUCTORS: ::core::primitive::usize = 1usize;
    }

    impl ::ink::traits::ContractDispatchableMessages<
        { <Delegator as ::ink::traits::ContractAmountDispatchables>::MESSAGES },
    > for Delegator {
        const IDS: [::core::primitive::u32; <Delegator as ::ink::traits::ContractAmountDispatchables>::MESSAGES] = [
            0x2F865BD9_u32,
            0x74A18249_u32,
            0x6A77FDD2_u32,
        ];
    }

    impl ::ink::traits::ContractDispatchableConstructors<
        { <Delegator as ::ink::traits::ContractAmountDispatchables>::CONSTRUCTORS },
    > for Delegator {
        const IDS: [::core::primitive::u32; <Delegator as ::ink::traits::ContractAmountDispatchables>::CONSTRUCTORS] = [
            0x9BAE9D5E_u32,
        ];
    }

    impl ::ink::traits::DispatchableConstructorInfo<0x9BAE9D5E_u32> for Delegator {
        type Input = (i32, u32, Hash, Hash, Hash);
        type Storage = Delegator;
        const CALLABLE: fn(Self::Input) -> Self::Storage = |(
                                                                __ink_binding_0,
                                                                __ink_binding_1,
                                                                __ink_binding_2,
                                                                __ink_binding_3,
                                                                __ink_binding_4,
                                                            )|
            {
                Delegator::new(
                    __ink_binding_0,
                    __ink_binding_1,
                    __ink_binding_2,
                    __ink_binding_3,
                    __ink_binding_4,
                )
            };
        const PAYABLE: ::core::primitive::bool = false;
        const SELECTOR: [::core::primitive::u8; 4usize] = [
            0x9B_u8,
            0xAE_u8,
            0x9D_u8,
            0x5E_u8,
        ];
        const LABEL: &'static ::core::primitive::str = "new";
    }

    impl ::ink::traits::DispatchableMessageInfo<0x2F865BD9_u32> for Delegator {
        type Input = i32;
        type Output = i32;
        type Storage = Delegator;
        const CALLABLE: fn(&mut Self::Storage, Self::Input) -> Self::Output = |storage,
                                                                               __ink_binding_0|
            { Delegator::get(storage, __ink_binding_0) };
        const SELECTOR: [::core::primitive::u8; 4usize] = [
            0x2F_u8,
            0x86_u8,
            0x5B_u8,
            0xD9_u8,
        ];
        const PAYABLE: ::core::primitive::bool = false;
        const MUTATES: ::core::primitive::bool = false;
        const LABEL: &'static ::core::primitive::str = "get";
    }

    impl ::ink::traits::DispatchableMessageInfo<0x74A18249_u32> for Delegator {
        type Input = i32;
        type Output = i32;
        type Storage = Delegator;
        const CALLABLE: fn(&mut Self::Storage, Self::Input) -> Self::Output = |storage,
                                                                               __ink_binding_0|
            { Delegator::net(storage, __ink_binding_0) };
        const SELECTOR: [::core::primitive::u8; 4usize] = [
            0x74_u8,
            0xA1_u8,
            0x82_u8,
            0x49_u8,
        ];
        const PAYABLE: ::core::primitive::bool = false;
        const MUTATES: ::core::primitive::bool = false;
        const LABEL: &'static ::core::primitive::str = "net";
    }

    impl ::ink::traits::DispatchableMessageInfo<0x6A77FDD2_u32> for Delegator {
        type Input = ();
        type Output = i32;
        type Storage = Delegator;
        const CALLABLE: fn(&mut Self::Storage, Self::Input) -> Self::Output = |storage,
                                                                               _|
            { Delegator::blabla(storage) };
        const SELECTOR: [::core::primitive::u8; 4usize] = [
            0x6A_u8,
            0x77_u8,
            0xFD_u8,
            0xD2_u8,
        ];
        const PAYABLE: ::core::primitive::bool = false;
        const MUTATES: ::core::primitive::bool = false;
        const LABEL: &'static ::core::primitive::str = "blabla";
    }

    const _: () = {
        #[allow(non_camel_case_types)]
        pub enum __ink_ConstructorDecoder {
            Constructor0(
                <Delegator as ::ink::traits::DispatchableConstructorInfo<
                    {
                        <Delegator as ::ink::traits::ContractDispatchableConstructors<
                            {
                                <Delegator as ::ink::traits::ContractAmountDispatchables>::CONSTRUCTORS
                            },
                        >>::IDS[0usize]
                    },
                >>::Input,
            ),
        }
        impl ::ink::traits::DecodeDispatch for __ink_ConstructorDecoder {
            fn decode_dispatch<I>(
                input: &mut I,
            ) -> ::core::result::Result<Self, ::ink::traits::DispatchError>
                where
                    I: ::scale::Input,
            {
                const CONSTRUCTOR_0: [::core::primitive::u8; 4usize] = <Delegator as ::ink::traits::DispatchableConstructorInfo<
                    {
                        <Delegator as ::ink::traits::ContractDispatchableConstructors<
                            {
                                <Delegator as ::ink::traits::ContractAmountDispatchables>::CONSTRUCTORS
                            },
                        >>::IDS[0usize]
                    },
                >>::SELECTOR;
                match <[::core::primitive::u8; 4usize] as ::scale::Decode>::decode(input)
                    .map_err(|_| ::ink::traits::DispatchError::InvalidSelector)?
                {
                    CONSTRUCTOR_0 => {
                        ::core::result::Result::Ok(
                            Self::Constructor0(
                                <<Delegator as ::ink::traits::DispatchableConstructorInfo<
                                    {
                                        <Delegator as ::ink::traits::ContractDispatchableConstructors<
                                            {
                                                <Delegator as ::ink::traits::ContractAmountDispatchables>::CONSTRUCTORS
                                            },
                                        >>::IDS[0usize]
                                    },
                                >>::Input as ::scale::Decode>::decode(input)
                                    .map_err(|_| {
                                        ::ink::traits::DispatchError::InvalidParameters
                                    })?,
                            ),
                        )
                    }
                    _invalid => {
                        ::core::result::Result::Err(
                            ::ink::traits::DispatchError::UnknownSelector,
                        )
                    }
                }
            }
        }
        impl ::scale::Decode for __ink_ConstructorDecoder {
            fn decode<I>(input: &mut I) -> ::core::result::Result<Self, ::scale::Error>
                where
                    I: ::scale::Input,
            {
                <Self as ::ink::traits::DecodeDispatch>::decode_dispatch(input)
                    .map_err(::core::convert::Into::into)
            }
        }
        impl ::ink::traits::ExecuteDispatchable for __ink_ConstructorDecoder {
            #[allow(clippy::nonminimal_bool)]
            fn execute_dispatchable(
                self,
            ) -> ::core::result::Result<(), ::ink::traits::DispatchError> {
                match self {
                    Self::Constructor0(input) => {
                        if {
                            false
                                || <Delegator as ::ink::traits::DispatchableConstructorInfo<
                                {
                                    <Delegator as ::ink::traits::ContractDispatchableConstructors<
                                        {
                                            <Delegator as ::ink::traits::ContractAmountDispatchables>::CONSTRUCTORS
                                        },
                                    >>::IDS[0usize]
                                },
                            >>::PAYABLE
                        }
                            && !<Delegator as ::ink::traits::DispatchableConstructorInfo<
                            {
                                <Delegator as ::ink::traits::ContractDispatchableConstructors<
                                    {
                                        <Delegator as ::ink::traits::ContractAmountDispatchables>::CONSTRUCTORS
                                    },
                                >>::IDS[0usize]
                            },
                        >>::PAYABLE
                        {
                            ::ink::codegen::deny_payment::<
                                <Delegator as ::ink::traits::ContractEnv>::Env,
                            >()?;
                        }
                        ::ink::codegen::execute_constructor::<
                            Delegator,
                            _,
                            _,
                        >(move || {
                            <Delegator as ::ink::traits::DispatchableConstructorInfo<
                                {
                                    <Delegator as ::ink::traits::ContractDispatchableConstructors<
                                        {
                                            <Delegator as ::ink::traits::ContractAmountDispatchables>::CONSTRUCTORS
                                        },
                                    >>::IDS[0usize]
                                },
                            >>::CALLABLE(input)
                        })
                    }
                }
            }
        }
        impl ::ink::traits::ContractConstructorDecoder for Delegator {
            type Type = __ink_ConstructorDecoder;
        }
    };
    const _: () = {
        #[allow(non_camel_case_types)]
        pub enum __ink_MessageDecoder {
            Message0(
                <Delegator as ::ink::traits::DispatchableMessageInfo<
                    {
                        <Delegator as ::ink::traits::ContractDispatchableMessages<
                            {
                                <Delegator as ::ink::traits::ContractAmountDispatchables>::MESSAGES
                            },
                        >>::IDS[0usize]
                    },
                >>::Input,
            ),
            Message1(
                <Delegator as ::ink::traits::DispatchableMessageInfo<
                    {
                        <Delegator as ::ink::traits::ContractDispatchableMessages<
                            {
                                <Delegator as ::ink::traits::ContractAmountDispatchables>::MESSAGES
                            },
                        >>::IDS[1usize]
                    },
                >>::Input,
            ),
            Message2(
                <Delegator as ::ink::traits::DispatchableMessageInfo<
                    {
                        <Delegator as ::ink::traits::ContractDispatchableMessages<
                            {
                                <Delegator as ::ink::traits::ContractAmountDispatchables>::MESSAGES
                            },
                        >>::IDS[2usize]
                    },
                >>::Input,
            ),
        }
        #[automatically_derived]
        #[allow(non_camel_case_types)]
        impl ::core::fmt::Debug for __ink_MessageDecoder {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match self {
                    __ink_MessageDecoder::Message0(__self_0) => {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(
                            f,
                            "Message0",
                            &__self_0,
                        )
                    }
                    __ink_MessageDecoder::Message1(__self_0) => {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(
                            f,
                            "Message1",
                            &__self_0,
                        )
                    }
                    __ink_MessageDecoder::Message2(__self_0) => {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(
                            f,
                            "Message2",
                            &__self_0,
                        )
                    }
                }
            }
        }
        impl ::ink::traits::DecodeDispatch for __ink_MessageDecoder {
            fn decode_dispatch<I>(
                input: &mut I,
            ) -> ::core::result::Result<Self, ::ink::traits::DispatchError>
                where
                    I: ::scale::Input,
            {
                ::ink_env::debug_message(
                    &{
                        let res = ::alloc::fmt::format(
                            ::core::fmt::Arguments::new_v1(
                                &["", "\n"],
                                &[
                                    ::core::fmt::ArgumentV1::new_display(
                                        &{
                                            let res = ::alloc::fmt::format(
                                                ::core::fmt::Arguments::new_v1(&["decode dispatch"], &[]),
                                            );
                                            res
                                        },
                                    ),
                                ],
                            ),
                        );
                        res
                    },
                );
                const MESSAGE_0: [::core::primitive::u8; 4usize] = <Delegator as ::ink::traits::DispatchableMessageInfo<
                    {
                        <Delegator as ::ink::traits::ContractDispatchableMessages<
                            {
                                <Delegator as ::ink::traits::ContractAmountDispatchables>::MESSAGES
                            },
                        >>::IDS[0usize]
                    },
                >>::SELECTOR;
                ::ink_env::debug_message(
                    &{
                        let res = ::alloc::fmt::format(
                            ::core::fmt::Arguments::new_v1(
                                &["", "\n"],
                                &[
                                    ::core::fmt::ArgumentV1::new_display(
                                        &{
                                            let res = ::alloc::fmt::format(
                                                ::core::fmt::Arguments::new_v1_formatted(
                                                    &["ident: "],
                                                    &[::core::fmt::ArgumentV1::new_debug(&MESSAGE_0)],
                                                    &[
                                                        ::core::fmt::rt::v1::Argument {
                                                            position: 0usize,
                                                            format: ::core::fmt::rt::v1::FormatSpec {
                                                                fill: ' ',
                                                                align: ::core::fmt::rt::v1::Alignment::Unknown,
                                                                flags: 40u32,
                                                                precision: ::core::fmt::rt::v1::Count::Implied,
                                                                width: ::core::fmt::rt::v1::Count::Is(2usize),
                                                            },
                                                        },
                                                    ],
                                                    unsafe { ::core::fmt::UnsafeArg::new() },
                                                ),
                                            );
                                            res
                                        },
                                    ),
                                ],
                            ),
                        );
                        res
                    },
                );
                const MESSAGE_1: [::core::primitive::u8; 4usize] = <Delegator as ::ink::traits::DispatchableMessageInfo<
                    {
                        <Delegator as ::ink::traits::ContractDispatchableMessages<
                            {
                                <Delegator as ::ink::traits::ContractAmountDispatchables>::MESSAGES
                            },
                        >>::IDS[1usize]
                    },
                >>::SELECTOR;
                ::ink_env::debug_message(
                    &{
                        let res = ::alloc::fmt::format(
                            ::core::fmt::Arguments::new_v1(
                                &["", "\n"],
                                &[
                                    ::core::fmt::ArgumentV1::new_display(
                                        &{
                                            let res = ::alloc::fmt::format(
                                                ::core::fmt::Arguments::new_v1_formatted(
                                                    &["ident: "],
                                                    &[::core::fmt::ArgumentV1::new_debug(&MESSAGE_1)],
                                                    &[
                                                        ::core::fmt::rt::v1::Argument {
                                                            position: 0usize,
                                                            format: ::core::fmt::rt::v1::FormatSpec {
                                                                fill: ' ',
                                                                align: ::core::fmt::rt::v1::Alignment::Unknown,
                                                                flags: 40u32,
                                                                precision: ::core::fmt::rt::v1::Count::Implied,
                                                                width: ::core::fmt::rt::v1::Count::Is(2usize),
                                                            },
                                                        },
                                                    ],
                                                    unsafe { ::core::fmt::UnsafeArg::new() },
                                                ),
                                            );
                                            res
                                        },
                                    ),
                                ],
                            ),
                        );
                        res
                    },
                );
                const MESSAGE_2: [::core::primitive::u8; 4usize] = <Delegator as ::ink::traits::DispatchableMessageInfo<
                    {
                        <Delegator as ::ink::traits::ContractDispatchableMessages<
                            {
                                <Delegator as ::ink::traits::ContractAmountDispatchables>::MESSAGES
                            },
                        >>::IDS[2usize]
                    },
                >>::SELECTOR;
                ::ink_env::debug_message(
                    &{
                        let res = ::alloc::fmt::format(
                            ::core::fmt::Arguments::new_v1(
                                &["", "\n"],
                                &[
                                    ::core::fmt::ArgumentV1::new_display(
                                        &{
                                            let res = ::alloc::fmt::format(
                                                ::core::fmt::Arguments::new_v1_formatted(
                                                    &["ident: "],
                                                    &[::core::fmt::ArgumentV1::new_debug(&MESSAGE_2)],
                                                    &[
                                                        ::core::fmt::rt::v1::Argument {
                                                            position: 0usize,
                                                            format: ::core::fmt::rt::v1::FormatSpec {
                                                                fill: ' ',
                                                                align: ::core::fmt::rt::v1::Alignment::Unknown,
                                                                flags: 40u32,
                                                                precision: ::core::fmt::rt::v1::Count::Implied,
                                                                width: ::core::fmt::rt::v1::Count::Is(2usize),
                                                            },
                                                        },
                                                    ],
                                                    unsafe { ::core::fmt::UnsafeArg::new() },
                                                ),
                                            );
                                            res
                                        },
                                    ),
                                ],
                            ),
                        );
                        res
                    },
                );
                ::ink_env::debug_message(
                    &{
                        let res = ::alloc::fmt::format(
                            ::core::fmt::Arguments::new_v1(
                                &["", "\n"],
                                &[
                                    ::core::fmt::ArgumentV1::new_display(
                                        &{
                                            let res = ::alloc::fmt::format(
                                                ::core::fmt::Arguments::new_v1(
                                                    &["input "],
                                                    &[
                                                        ::core::fmt::ArgumentV1::new_debug(&input.remaining_len()),
                                                    ],
                                                ),
                                            );
                                            res
                                        },
                                    ),
                                ],
                            ),
                        );
                        res
                    },
                );
                let foo = <[::core::primitive::u8; 4usize] as ::scale::Decode>::decode(
                    input,
                );
                ::ink_env::debug_message(
                    &{
                        let res = ::alloc::fmt::format(
                            ::core::fmt::Arguments::new_v1(
                                &["", "\n"],
                                &[
                                    ::core::fmt::ArgumentV1::new_display(
                                        &{
                                            let res = ::alloc::fmt::format(
                                                ::core::fmt::Arguments::new_v1_formatted(
                                                    &["decoded input "],
                                                    &[
                                                        ::core::fmt::ArgumentV1::new_debug(
                                                            &foo.as_ref().expect("decoded input"),
                                                        ),
                                                    ],
                                                    &[
                                                        ::core::fmt::rt::v1::Argument {
                                                            position: 0usize,
                                                            format: ::core::fmt::rt::v1::FormatSpec {
                                                                fill: ' ',
                                                                align: ::core::fmt::rt::v1::Alignment::Unknown,
                                                                flags: 40u32,
                                                                precision: ::core::fmt::rt::v1::Count::Implied,
                                                                width: ::core::fmt::rt::v1::Count::Is(2usize),
                                                            },
                                                        },
                                                    ],
                                                    unsafe { ::core::fmt::UnsafeArg::new() },
                                                ),
                                            );
                                            res
                                        },
                                    ),
                                ],
                            ),
                        );
                        res
                    },
                );
                let bar = match foo
                    .map_err(|err| {
                        ::ink_env::debug_message(
                            &{
                                let res = ::alloc::fmt::format(
                                    ::core::fmt::Arguments::new_v1(
                                        &["", "\n"],
                                        &[
                                            ::core::fmt::ArgumentV1::new_display(
                                                &{
                                                    let res = ::alloc::fmt::format(
                                                        ::core::fmt::Arguments::new_v1(&["invalid selector"], &[]),
                                                    );
                                                    res
                                                },
                                            ),
                                        ],
                                    ),
                                );
                                res
                            },
                        );
                        ::ink::traits::DispatchError::InvalidSelector
                    })?
                {
                    MESSAGE_0 => {
                        ::core::result::Result::Ok(
                            Self::Message0(
                                <<Delegator as ::ink::traits::DispatchableMessageInfo<
                                    {
                                        <Delegator as ::ink::traits::ContractDispatchableMessages<
                                            {
                                                <Delegator as ::ink::traits::ContractAmountDispatchables>::MESSAGES
                                            },
                                        >>::IDS[0usize]
                                    },
                                >>::Input as ::scale::Decode>::decode(input)
                                    .map_err(|_| {
                                        ::ink::traits::DispatchError::InvalidParameters
                                    })?,
                            ),
                        )
                    }
                    MESSAGE_1 => {
                        ::core::result::Result::Ok(
                            Self::Message1(
                                <<Delegator as ::ink::traits::DispatchableMessageInfo<
                                    {
                                        <Delegator as ::ink::traits::ContractDispatchableMessages<
                                            {
                                                <Delegator as ::ink::traits::ContractAmountDispatchables>::MESSAGES
                                            },
                                        >>::IDS[1usize]
                                    },
                                >>::Input as ::scale::Decode>::decode(input)
                                    .map_err(|_| {
                                        ::ink::traits::DispatchError::InvalidParameters
                                    })?,
                            ),
                        )
                    }
                    MESSAGE_2 => {
                        ::core::result::Result::Ok(
                            Self::Message2(
                                <<Delegator as ::ink::traits::DispatchableMessageInfo<
                                    {
                                        <Delegator as ::ink::traits::ContractDispatchableMessages<
                                            {
                                                <Delegator as ::ink::traits::ContractAmountDispatchables>::MESSAGES
                                            },
                                        >>::IDS[2usize]
                                    },
                                >>::Input as ::scale::Decode>::decode(input)
                                    .map_err(|_| {
                                        ::ink::traits::DispatchError::InvalidParameters
                                    })?,
                            ),
                        )
                    }
                    _invalid => {
                        ::ink_env::debug_message(
                            &{
                                let res = ::alloc::fmt::format(
                                    ::core::fmt::Arguments::new_v1(
                                        &["", "\n"],
                                        &[
                                            ::core::fmt::ArgumentV1::new_display(
                                                &{
                                                    let res = ::alloc::fmt::format(
                                                        ::core::fmt::Arguments::new_v1(
                                                            &["invalid selector branch"],
                                                            &[],
                                                        ),
                                                    );
                                                    res
                                                },
                                            ),
                                        ],
                                    ),
                                );
                                res
                            },
                        );
                        {
                            ::ink_env::debug_message(
                                &{
                                    let res = ::alloc::fmt::format(
                                        ::core::fmt::Arguments::new_v1(
                                            &["", "\n"],
                                            &[
                                                ::core::fmt::ArgumentV1::new_display(
                                                    &{
                                                        let res = ::alloc::fmt::format(
                                                            ::core::fmt::Arguments::new_v1(&["hiha"], &[]),
                                                        );
                                                        res
                                                    },
                                                ),
                                            ],
                                        ),
                                    );
                                    res
                                },
                            );
                            ::core::result::Result::Err(
                                ::ink::traits::DispatchError::UnknownSelector,
                            )
                        }
                    }
                };
                ::ink_env::debug_message(
                    &{
                        let res = ::alloc::fmt::format(
                            ::core::fmt::Arguments::new_v1(
                                &["", "\n"],
                                &[
                                    ::core::fmt::ArgumentV1::new_display(
                                        &{
                                            let res = ::alloc::fmt::format(
                                                ::core::fmt::Arguments::new_v1(
                                                    &["input success "],
                                                    &[
                                                        ::core::fmt::ArgumentV1::new_debug(&input.remaining_len()),
                                                    ],
                                                ),
                                            );
                                            res
                                        },
                                    ),
                                ],
                            ),
                        );
                        res
                    },
                );
                bar
            }
        }
        impl ::scale::Decode for __ink_MessageDecoder {
            fn decode<I>(input: &mut I) -> ::core::result::Result<Self, ::scale::Error>
                where
                    I: ::scale::Input,
            {
                ::ink_env::debug_message(
                    &{
                        let res = ::alloc::fmt::format(
                            ::core::fmt::Arguments::new_v1(
                                &["", "\n"],
                                &[
                                    ::core::fmt::ArgumentV1::new_display(
                                        &{
                                            let res = ::alloc::fmt::format(
                                                ::core::fmt::Arguments::new_v1(&["decode "], &[]),
                                            );
                                            res
                                        },
                                    ),
                                ],
                            ),
                        );
                        res
                    },
                );
                let foo = <Self as ::ink::traits::DecodeDispatch>::decode_dispatch(
                    input,
                );
                ::ink_env::debug_message(
                    &{
                        let res = ::alloc::fmt::format(
                            ::core::fmt::Arguments::new_v1(
                                &["", "\n"],
                                &[
                                    ::core::fmt::ArgumentV1::new_display(
                                        &{
                                            let res = ::alloc::fmt::format(
                                                ::core::fmt::Arguments::new_v1(
                                                    &["after decode "],
                                                    &[::core::fmt::ArgumentV1::new_debug(&foo)],
                                                ),
                                            );
                                            res
                                        },
                                    ),
                                ],
                            ),
                        );
                        res
                    },
                );
                let foo = foo.map_err(::core::convert::Into::into);
                ::ink_env::debug_message(
                    &{
                        let res = ::alloc::fmt::format(
                            ::core::fmt::Arguments::new_v1(
                                &["", "\n"],
                                &[
                                    ::core::fmt::ArgumentV1::new_display(
                                        &{
                                            let res = ::alloc::fmt::format(
                                                ::core::fmt::Arguments::new_v1(
                                                    &["after decode "],
                                                    &[::core::fmt::ArgumentV1::new_debug(&foo)],
                                                ),
                                            );
                                            res
                                        },
                                    ),
                                ],
                            ),
                        );
                        res
                    },
                );
                foo
            }
        }
        fn push_contract(contract: ::core::mem::ManuallyDrop<Delegator>, mutates: bool) {
            if mutates {
                ::ink::env::set_contract_storage::<
                    ::ink::primitives::Key,
                    Delegator,
                >(&<Delegator as ::ink::storage::traits::StorageKey>::KEY, &contract);
            }
        }
        impl ::ink::traits::ExecuteDispatchable for __ink_MessageDecoder {
            #[allow(clippy::nonminimal_bool, clippy::let_unit_value)]
            fn execute_dispatchable(
                self,
            ) -> ::core::result::Result<(), ::ink::traits::DispatchError> {
                ::ink_env::debug_message(
                    &{
                        let res = ::alloc::fmt::format(
                            ::core::fmt::Arguments::new_v1(
                                &["", "\n"],
                                &[
                                    ::core::fmt::ArgumentV1::new_display(
                                        &{
                                            let res = ::alloc::fmt::format(
                                                ::core::fmt::Arguments::new_v1(
                                                    &["execute dispatchable"],
                                                    &[],
                                                ),
                                            );
                                            res
                                        },
                                    ),
                                ],
                            ),
                        );
                        res
                    },
                );
                let key = <Delegator as ::ink::storage::traits::StorageKey>::KEY;
                let mut contract: ::core::mem::ManuallyDrop<Delegator> = ::core::mem::ManuallyDrop::new(
                    match ::ink::env::get_contract_storage(&key) {
                        ::core::result::Result::Ok(
                            ::core::option::Option::Some(value),
                        ) => value,
                        ::core::result::Result::Ok(::core::option::Option::None) => {
                            ::core::panicking::panic_fmt(
                                ::core::fmt::Arguments::new_v1(
                                    &["storage entry was empty"],
                                    &[],
                                ),
                            )
                        }
                        ::core::result::Result::Err(_) => {
                            ::core::panicking::panic_fmt(
                                ::core::fmt::Arguments::new_v1(
                                    &["could not properly decode storage entry"],
                                    &[],
                                ),
                            )
                        }
                    },
                );
                match self {
                    Self::Message0(input) => {
                        use ::core::default::Default;
                        if {
                            false
                                || <Delegator as ::ink::traits::DispatchableMessageInfo<
                                {
                                    <Delegator as ::ink::traits::ContractDispatchableMessages<
                                        {
                                            <Delegator as ::ink::traits::ContractAmountDispatchables>::MESSAGES
                                        },
                                    >>::IDS[0usize]
                                },
                            >>::PAYABLE
                                || <Delegator as ::ink::traits::DispatchableMessageInfo<
                                {
                                    <Delegator as ::ink::traits::ContractDispatchableMessages<
                                        {
                                            <Delegator as ::ink::traits::ContractAmountDispatchables>::MESSAGES
                                        },
                                    >>::IDS[1usize]
                                },
                            >>::PAYABLE
                                || <Delegator as ::ink::traits::DispatchableMessageInfo<
                                {
                                    <Delegator as ::ink::traits::ContractDispatchableMessages<
                                        {
                                            <Delegator as ::ink::traits::ContractAmountDispatchables>::MESSAGES
                                        },
                                    >>::IDS[2usize]
                                },
                            >>::PAYABLE
                        }
                            && !<Delegator as ::ink::traits::DispatchableMessageInfo<
                            {
                                <Delegator as ::ink::traits::ContractDispatchableMessages<
                                    {
                                        <Delegator as ::ink::traits::ContractAmountDispatchables>::MESSAGES
                                    },
                                >>::IDS[0usize]
                            },
                        >>::PAYABLE
                        {
                            ::ink::codegen::deny_payment::<
                                <Delegator as ::ink::traits::ContractEnv>::Env,
                            >()?;
                        }
                        let result: <Delegator as ::ink::traits::DispatchableMessageInfo<
                            {
                                <Delegator as ::ink::traits::ContractDispatchableMessages<
                                    {
                                        <Delegator as ::ink::traits::ContractAmountDispatchables>::MESSAGES
                                    },
                                >>::IDS[0usize]
                            },
                        >>::Output = <Delegator as ::ink::traits::DispatchableMessageInfo<
                            {
                                <Delegator as ::ink::traits::ContractDispatchableMessages<
                                    {
                                        <Delegator as ::ink::traits::ContractAmountDispatchables>::MESSAGES
                                    },
                                >>::IDS[0usize]
                            },
                        >>::CALLABLE(&mut contract, input);
                        let failure = {
                            #[allow(unused_imports)]
                            use ::ink::result_info::IsResultTypeFallback as _;
                            ::ink::result_info::IsResultType::<
                                <Delegator as ::ink::traits::DispatchableMessageInfo<
                                    {
                                        <Delegator as ::ink::traits::ContractDispatchableMessages<
                                            {
                                                <Delegator as ::ink::traits::ContractAmountDispatchables>::MESSAGES
                                            },
                                        >>::IDS[0usize]
                                    },
                                >>::Output,
                            >::VALUE
                        }
                            && {
                            #[allow(unused_imports)]
                            use ::ink::result_info::IsResultErrFallback as _;
                            ::ink::result_info::IsResultErr(&result).value()
                        };
                        if failure {
                            ::ink::env::return_value::<
                                <Delegator as ::ink::traits::DispatchableMessageInfo<
                                    {
                                        <Delegator as ::ink::traits::ContractDispatchableMessages<
                                            {
                                                <Delegator as ::ink::traits::ContractAmountDispatchables>::MESSAGES
                                            },
                                        >>::IDS[0usize]
                                    },
                                >>::Output,
                            >(
                                ::ink::env::ReturnFlags::default().set_reverted(true),
                                &result,
                            )
                        }
                        push_contract(
                            contract,
                            <Delegator as ::ink::traits::DispatchableMessageInfo<
                                {
                                    <Delegator as ::ink::traits::ContractDispatchableMessages<
                                        {
                                            <Delegator as ::ink::traits::ContractAmountDispatchables>::MESSAGES
                                        },
                                    >>::IDS[0usize]
                                },
                            >>::MUTATES,
                        );
                        if ::core::any::TypeId::of::<
                            <Delegator as ::ink::traits::DispatchableMessageInfo<
                                {
                                    <Delegator as ::ink::traits::ContractDispatchableMessages<
                                        {
                                            <Delegator as ::ink::traits::ContractAmountDispatchables>::MESSAGES
                                        },
                                    >>::IDS[0usize]
                                },
                            >>::Output,
                        >() != ::core::any::TypeId::of::<()>()
                        {
                            ::ink::env::return_value::<
                                <Delegator as ::ink::traits::DispatchableMessageInfo<
                                    {
                                        <Delegator as ::ink::traits::ContractDispatchableMessages<
                                            {
                                                <Delegator as ::ink::traits::ContractAmountDispatchables>::MESSAGES
                                            },
                                        >>::IDS[0usize]
                                    },
                                >>::Output,
                            >(::ink::env::ReturnFlags::default(), &result)
                        }
                    }
                    Self::Message1(input) => {
                        use ::core::default::Default;
                        if {
                            false
                                || <Delegator as ::ink::traits::DispatchableMessageInfo<
                                {
                                    <Delegator as ::ink::traits::ContractDispatchableMessages<
                                        {
                                            <Delegator as ::ink::traits::ContractAmountDispatchables>::MESSAGES
                                        },
                                    >>::IDS[0usize]
                                },
                            >>::PAYABLE
                                || <Delegator as ::ink::traits::DispatchableMessageInfo<
                                {
                                    <Delegator as ::ink::traits::ContractDispatchableMessages<
                                        {
                                            <Delegator as ::ink::traits::ContractAmountDispatchables>::MESSAGES
                                        },
                                    >>::IDS[1usize]
                                },
                            >>::PAYABLE
                                || <Delegator as ::ink::traits::DispatchableMessageInfo<
                                {
                                    <Delegator as ::ink::traits::ContractDispatchableMessages<
                                        {
                                            <Delegator as ::ink::traits::ContractAmountDispatchables>::MESSAGES
                                        },
                                    >>::IDS[2usize]
                                },
                            >>::PAYABLE
                        }
                            && !<Delegator as ::ink::traits::DispatchableMessageInfo<
                            {
                                <Delegator as ::ink::traits::ContractDispatchableMessages<
                                    {
                                        <Delegator as ::ink::traits::ContractAmountDispatchables>::MESSAGES
                                    },
                                >>::IDS[1usize]
                            },
                        >>::PAYABLE
                        {
                            ::ink::codegen::deny_payment::<
                                <Delegator as ::ink::traits::ContractEnv>::Env,
                            >()?;
                        }
                        let result: <Delegator as ::ink::traits::DispatchableMessageInfo<
                            {
                                <Delegator as ::ink::traits::ContractDispatchableMessages<
                                    {
                                        <Delegator as ::ink::traits::ContractAmountDispatchables>::MESSAGES
                                    },
                                >>::IDS[1usize]
                            },
                        >>::Output = <Delegator as ::ink::traits::DispatchableMessageInfo<
                            {
                                <Delegator as ::ink::traits::ContractDispatchableMessages<
                                    {
                                        <Delegator as ::ink::traits::ContractAmountDispatchables>::MESSAGES
                                    },
                                >>::IDS[1usize]
                            },
                        >>::CALLABLE(&mut contract, input);
                        let failure = {
                            #[allow(unused_imports)]
                            use ::ink::result_info::IsResultTypeFallback as _;
                            ::ink::result_info::IsResultType::<
                                <Delegator as ::ink::traits::DispatchableMessageInfo<
                                    {
                                        <Delegator as ::ink::traits::ContractDispatchableMessages<
                                            {
                                                <Delegator as ::ink::traits::ContractAmountDispatchables>::MESSAGES
                                            },
                                        >>::IDS[1usize]
                                    },
                                >>::Output,
                            >::VALUE
                        }
                            && {
                            #[allow(unused_imports)]
                            use ::ink::result_info::IsResultErrFallback as _;
                            ::ink::result_info::IsResultErr(&result).value()
                        };
                        if failure {
                            ::ink::env::return_value::<
                                <Delegator as ::ink::traits::DispatchableMessageInfo<
                                    {
                                        <Delegator as ::ink::traits::ContractDispatchableMessages<
                                            {
                                                <Delegator as ::ink::traits::ContractAmountDispatchables>::MESSAGES
                                            },
                                        >>::IDS[1usize]
                                    },
                                >>::Output,
                            >(
                                ::ink::env::ReturnFlags::default().set_reverted(true),
                                &result,
                            )
                        }
                        push_contract(
                            contract,
                            <Delegator as ::ink::traits::DispatchableMessageInfo<
                                {
                                    <Delegator as ::ink::traits::ContractDispatchableMessages<
                                        {
                                            <Delegator as ::ink::traits::ContractAmountDispatchables>::MESSAGES
                                        },
                                    >>::IDS[1usize]
                                },
                            >>::MUTATES,
                        );
                        if ::core::any::TypeId::of::<
                            <Delegator as ::ink::traits::DispatchableMessageInfo<
                                {
                                    <Delegator as ::ink::traits::ContractDispatchableMessages<
                                        {
                                            <Delegator as ::ink::traits::ContractAmountDispatchables>::MESSAGES
                                        },
                                    >>::IDS[1usize]
                                },
                            >>::Output,
                        >() != ::core::any::TypeId::of::<()>()
                        {
                            ::ink::env::return_value::<
                                <Delegator as ::ink::traits::DispatchableMessageInfo<
                                    {
                                        <Delegator as ::ink::traits::ContractDispatchableMessages<
                                            {
                                                <Delegator as ::ink::traits::ContractAmountDispatchables>::MESSAGES
                                            },
                                        >>::IDS[1usize]
                                    },
                                >>::Output,
                            >(::ink::env::ReturnFlags::default(), &result)
                        }
                    }
                    Self::Message2(input) => {
                        use ::core::default::Default;
                        if {
                            false
                                || <Delegator as ::ink::traits::DispatchableMessageInfo<
                                {
                                    <Delegator as ::ink::traits::ContractDispatchableMessages<
                                        {
                                            <Delegator as ::ink::traits::ContractAmountDispatchables>::MESSAGES
                                        },
                                    >>::IDS[0usize]
                                },
                            >>::PAYABLE
                                || <Delegator as ::ink::traits::DispatchableMessageInfo<
                                {
                                    <Delegator as ::ink::traits::ContractDispatchableMessages<
                                        {
                                            <Delegator as ::ink::traits::ContractAmountDispatchables>::MESSAGES
                                        },
                                    >>::IDS[1usize]
                                },
                            >>::PAYABLE
                                || <Delegator as ::ink::traits::DispatchableMessageInfo<
                                {
                                    <Delegator as ::ink::traits::ContractDispatchableMessages<
                                        {
                                            <Delegator as ::ink::traits::ContractAmountDispatchables>::MESSAGES
                                        },
                                    >>::IDS[2usize]
                                },
                            >>::PAYABLE
                        }
                            && !<Delegator as ::ink::traits::DispatchableMessageInfo<
                            {
                                <Delegator as ::ink::traits::ContractDispatchableMessages<
                                    {
                                        <Delegator as ::ink::traits::ContractAmountDispatchables>::MESSAGES
                                    },
                                >>::IDS[2usize]
                            },
                        >>::PAYABLE
                        {
                            ::ink::codegen::deny_payment::<
                                <Delegator as ::ink::traits::ContractEnv>::Env,
                            >()?;
                        }
                        let result: <Delegator as ::ink::traits::DispatchableMessageInfo<
                            {
                                <Delegator as ::ink::traits::ContractDispatchableMessages<
                                    {
                                        <Delegator as ::ink::traits::ContractAmountDispatchables>::MESSAGES
                                    },
                                >>::IDS[2usize]
                            },
                        >>::Output = <Delegator as ::ink::traits::DispatchableMessageInfo<
                            {
                                <Delegator as ::ink::traits::ContractDispatchableMessages<
                                    {
                                        <Delegator as ::ink::traits::ContractAmountDispatchables>::MESSAGES
                                    },
                                >>::IDS[2usize]
                            },
                        >>::CALLABLE(&mut contract, input);
                        let failure = {
                            #[allow(unused_imports)]
                            use ::ink::result_info::IsResultTypeFallback as _;
                            ::ink::result_info::IsResultType::<
                                <Delegator as ::ink::traits::DispatchableMessageInfo<
                                    {
                                        <Delegator as ::ink::traits::ContractDispatchableMessages<
                                            {
                                                <Delegator as ::ink::traits::ContractAmountDispatchables>::MESSAGES
                                            },
                                        >>::IDS[2usize]
                                    },
                                >>::Output,
                            >::VALUE
                        }
                            && {
                            #[allow(unused_imports)]
                            use ::ink::result_info::IsResultErrFallback as _;
                            ::ink::result_info::IsResultErr(&result).value()
                        };
                        if failure {
                            ::ink::env::return_value::<
                                <Delegator as ::ink::traits::DispatchableMessageInfo<
                                    {
                                        <Delegator as ::ink::traits::ContractDispatchableMessages<
                                            {
                                                <Delegator as ::ink::traits::ContractAmountDispatchables>::MESSAGES
                                            },
                                        >>::IDS[2usize]
                                    },
                                >>::Output,
                            >(
                                ::ink::env::ReturnFlags::default().set_reverted(true),
                                &result,
                            )
                        }
                        push_contract(
                            contract,
                            <Delegator as ::ink::traits::DispatchableMessageInfo<
                                {
                                    <Delegator as ::ink::traits::ContractDispatchableMessages<
                                        {
                                            <Delegator as ::ink::traits::ContractAmountDispatchables>::MESSAGES
                                        },
                                    >>::IDS[2usize]
                                },
                            >>::MUTATES,
                        );
                        if ::core::any::TypeId::of::<
                            <Delegator as ::ink::traits::DispatchableMessageInfo<
                                {
                                    <Delegator as ::ink::traits::ContractDispatchableMessages<
                                        {
                                            <Delegator as ::ink::traits::ContractAmountDispatchables>::MESSAGES
                                        },
                                    >>::IDS[2usize]
                                },
                            >>::Output,
                        >() != ::core::any::TypeId::of::<()>()
                        {
                            ::ink::env::return_value::<
                                <Delegator as ::ink::traits::DispatchableMessageInfo<
                                    {
                                        <Delegator as ::ink::traits::ContractDispatchableMessages<
                                            {
                                                <Delegator as ::ink::traits::ContractAmountDispatchables>::MESSAGES
                                            },
                                        >>::IDS[2usize]
                                    },
                                >>::Output,
                            >(::ink::env::ReturnFlags::default(), &result)
                        }
                    }
                };
                ::core::result::Result::Ok(())
            }
        }
        impl ::ink::traits::ContractMessageDecoder for Delegator {
            type Type = __ink_MessageDecoder;
        }
    };
    #[cfg(not(test))]
    #[cfg(not(feature = "ink-as-dependency"))]
    const _: () = {
        #[cfg(not(test))]
        #[no_mangle]
        #[allow(clippy::nonminimal_bool)]
        fn deploy() {
            if !{
                false
                    || <Delegator as ::ink::traits::DispatchableConstructorInfo<
                    {
                        <Delegator as ::ink::traits::ContractDispatchableConstructors<
                            {
                                <Delegator as ::ink::traits::ContractAmountDispatchables>::CONSTRUCTORS
                            },
                        >>::IDS[0usize]
                    },
                >>::PAYABLE
            } {
                ::ink::codegen::deny_payment::<
                    <Delegator as ::ink::traits::ContractEnv>::Env,
                >()
                    .unwrap_or_else(|error| ::core::panicking::panic_display(&error))
            }
            ::ink::env::decode_input::<
                <Delegator as ::ink::traits::ContractConstructorDecoder>::Type,
            >()
                .map_err(|err| {
                    ::ink_env::debug_message(
                        &{
                            let res = ::alloc::fmt::format(
                                ::core::fmt::Arguments::new_v1(
                                    &["", "\n"],
                                    &[
                                        ::core::fmt::ArgumentV1::new_display(
                                            &{
                                                let res = ::alloc::fmt::format(
                                                    ::core::fmt::Arguments::new_v1(
                                                        &["err: "],
                                                        &[::core::fmt::ArgumentV1::new_debug(&err)],
                                                    ),
                                                );
                                                res
                                            },
                                        ),
                                    ],
                                ),
                            );
                            res
                        },
                    );
                    ::ink::traits::DispatchError::CouldNotReadInput
                })
                .and_then(|decoder| {
                    <<Delegator as ::ink::traits::ContractConstructorDecoder>::Type as ::ink::traits::ExecuteDispatchable>::execute_dispatchable(
                        decoder,
                    )
                })
                .unwrap_or_else(|error| {
                    ::core::panicking::panic_fmt(
                        ::core::fmt::Arguments::new_v1(
                            &["dispatching ink! constructor failed: "],
                            &[::core::fmt::ArgumentV1::new_display(&error)],
                        ),
                    )
                })
        }
        #[cfg(not(test))]
        #[no_mangle]
        #[allow(clippy::nonminimal_bool)]
        fn call() {
            ::ink_env::debug_message(
                &{
                    let res = ::alloc::fmt::format(
                        ::core::fmt::Arguments::new_v1(
                            &["", "\n"],
                            &[
                                ::core::fmt::ArgumentV1::new_display(
                                    &{
                                        let res = ::alloc::fmt::format(
                                            ::core::fmt::Arguments::new_v1(&["call"], &[]),
                                        );
                                        res
                                    },
                                ),
                            ],
                        ),
                    );
                    res
                },
            );
            if !{
                false
                    || <Delegator as ::ink::traits::DispatchableMessageInfo<
                    {
                        <Delegator as ::ink::traits::ContractDispatchableMessages<
                            {
                                <Delegator as ::ink::traits::ContractAmountDispatchables>::MESSAGES
                            },
                        >>::IDS[0usize]
                    },
                >>::PAYABLE
                    || <Delegator as ::ink::traits::DispatchableMessageInfo<
                    {
                        <Delegator as ::ink::traits::ContractDispatchableMessages<
                            {
                                <Delegator as ::ink::traits::ContractAmountDispatchables>::MESSAGES
                            },
                        >>::IDS[1usize]
                    },
                >>::PAYABLE
                    || <Delegator as ::ink::traits::DispatchableMessageInfo<
                    {
                        <Delegator as ::ink::traits::ContractDispatchableMessages<
                            {
                                <Delegator as ::ink::traits::ContractAmountDispatchables>::MESSAGES
                            },
                        >>::IDS[2usize]
                    },
                >>::PAYABLE
            } {
                ::ink::codegen::deny_payment::<
                    <Delegator as ::ink::traits::ContractEnv>::Env,
                >()
                    .unwrap_or_else(|error| ::core::panicking::panic_display(&error))
            }
            ::ink::env::decode_input::<
                <Delegator as ::ink::traits::ContractMessageDecoder>::Type,
            >()
                .map_err(|err| {
                    ::ink_env::debug_message(
                        &{
                            let res = ::alloc::fmt::format(
                                ::core::fmt::Arguments::new_v1(
                                    &["", "\n"],
                                    &[
                                        ::core::fmt::ArgumentV1::new_display(
                                            &{
                                                let res = ::alloc::fmt::format(
                                                    ::core::fmt::Arguments::new_v1(
                                                        &["err here: "],
                                                        &[::core::fmt::ArgumentV1::new_debug(&err)],
                                                    ),
                                                );
                                                res
                                            },
                                        ),
                                    ],
                                ),
                            );
                            res
                        },
                    );
                    ::ink::traits::DispatchError::CouldNotReadInput
                })
                .and_then(|decoder| {
                    <<Delegator as ::ink::traits::ContractMessageDecoder>::Type as ::ink::traits::ExecuteDispatchable>::execute_dispatchable(
                        decoder,
                    )
                })
                .unwrap_or_else(|error| {
                    ::core::panicking::panic_fmt(
                        ::core::fmt::Arguments::new_v1(
                            &["dispatching ink! message failed: "],
                            &[::core::fmt::ArgumentV1::new_display(&error)],
                        ),
                    )
                })
        }
    };
    const _: () = {
        use ::ink::codegen::{Env as _, StaticEnv as _};
        const _: ::ink::codegen::utils::IsSameType<Delegator> = ::ink::codegen::utils::IsSameType::<
            Delegator,
        >::new();
        impl Delegator {
            /// Instantiate a `delegator` contract with the given sub-contract codes.
            #[cfg(not(feature = "__ink_dylint_Constructor"))]
            pub fn new(
                init_value: i32,
                version: u32,
                accumulator_code_hash: Hash,
                _adder_code_hash: Hash,
                _subber_code_hash: Hash,
            ) -> Self {
                let total_balance = Self::env().balance();
                let salt = version.to_le_bytes();
                let accumulator = AccumulatorRef::new(init_value)
                    .endowment(total_balance / 4)
                    .code_hash(accumulator_code_hash)
                    .salt_bytes(salt)
                    .instantiate()
                    .unwrap_or_else(|error| {
                        ::core::panicking::panic_fmt(
                            ::core::fmt::Arguments::new_v1(
                                &["failed at instantiating the Accumulator contract: "],
                                &[::core::fmt::ArgumentV1::new_debug(&error)],
                            ),
                        )
                    });
                Self {
                    which: Which::Adder,
                    accumulator,
                }
            }
            /// Returns the `accumulator` value.
            pub fn get(&self, _a: i32) -> i32 {
                1234
            }
            /// Returns the `accumulator` value.
            pub fn net(&self, _a: i32) -> i32 {
                1234
            }
            /// Returns the `accumulator` value 2.
            pub fn blabla(&self) -> i32 {
                13
            }
        }
        const _: () = {
            ::ink::codegen::utils::consume_type::<::ink::codegen::DispatchInput<i32>>();
            ::ink::codegen::utils::consume_type::<::ink::codegen::DispatchInput<u32>>();
            ::ink::codegen::utils::consume_type::<::ink::codegen::DispatchInput<Hash>>();
            ::ink::codegen::utils::consume_type::<::ink::codegen::DispatchInput<Hash>>();
            ::ink::codegen::utils::consume_type::<::ink::codegen::DispatchInput<Hash>>();
            ::ink::codegen::utils::consume_type::<::ink::codegen::DispatchInput<i32>>();
            ::ink::codegen::utils::consume_type::<::ink::codegen::DispatchOutput<i32>>();
            ::ink::codegen::utils::consume_type::<::ink::codegen::DispatchInput<i32>>();
            ::ink::codegen::utils::consume_type::<::ink::codegen::DispatchOutput<i32>>();
            ::ink::codegen::utils::consume_type::<::ink::codegen::DispatchOutput<i32>>();
        };
    };
    const _: () = {
        /// The ink! smart contract's call builder.
        ///
        /// Implements the underlying on-chain calling of the ink! smart contract
        /// messages and trait implementations in a type safe way.
        #[repr(transparent)]
        pub struct CallBuilder {
            account_id: AccountId,
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for CallBuilder {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field1_finish(
                    f,
                    "CallBuilder",
                    "account_id",
                    &&self.account_id,
                )
            }
        }
        #[allow(deprecated)]
        const _: () = {
            #[automatically_derived]
            impl ::scale::Encode for CallBuilder {
                fn encode_to<
                    __CodecOutputEdqy: ::scale::Output + ?::core::marker::Sized,
                >(&self, __codec_dest_edqy: &mut __CodecOutputEdqy) {
                    ::scale::Encode::encode_to(&&self.account_id, __codec_dest_edqy)
                }
                fn encode(&self) -> ::scale::alloc::vec::Vec<::core::primitive::u8> {
                    ::scale::Encode::encode(&&self.account_id)
                }
                fn using_encoded<
                    R,
                    F: ::core::ops::FnOnce(&[::core::primitive::u8]) -> R,
                >(&self, f: F) -> R {
                    ::scale::Encode::using_encoded(&&self.account_id, f)
                }
            }
            #[automatically_derived]
            impl ::scale::EncodeLike for CallBuilder {}
        };
        #[allow(deprecated)]
        const _: () = {
            #[automatically_derived]
            impl ::scale::Decode for CallBuilder {
                fn decode<__CodecInputEdqy: ::scale::Input>(
                    __codec_input_edqy: &mut __CodecInputEdqy,
                ) -> ::core::result::Result<Self, ::scale::Error> {
                    ::core::result::Result::Ok(CallBuilder {
                        account_id: {
                            let __codec_res_edqy = <AccountId as ::scale::Decode>::decode(
                                __codec_input_edqy,
                            );
                            match __codec_res_edqy {
                                ::core::result::Result::Err(e) => {
                                    return ::core::result::Result::Err(
                                        e.chain("Could not decode `CallBuilder::account_id`"),
                                    );
                                }
                                ::core::result::Result::Ok(__codec_res_edqy) => {
                                    __codec_res_edqy
                                }
                            }
                        },
                    })
                }
            }
        };
        #[automatically_derived]
        impl ::core::hash::Hash for CallBuilder {
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                ::core::hash::Hash::hash(&self.account_id, state)
            }
        }
        impl ::core::marker::StructuralPartialEq for CallBuilder {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for CallBuilder {
            #[inline]
            fn eq(&self, other: &CallBuilder) -> bool {
                self.account_id == other.account_id
            }
        }
        impl ::core::marker::StructuralEq for CallBuilder {}
        #[automatically_derived]
        impl ::core::cmp::Eq for CallBuilder {
            #[inline]
            #[doc(hidden)]
            #[no_coverage]
            fn assert_receiver_is_total_eq(&self) -> () {
                let _: ::core::cmp::AssertParamIsEq<AccountId>;
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for CallBuilder {
            #[inline]
            fn clone(&self) -> CallBuilder {
                CallBuilder {
                    account_id: ::core::clone::Clone::clone(&self.account_id),
                }
            }
        }
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            impl ::scale_info::TypeInfo for CallBuilder {
                type Identity = Self;
                fn type_info() -> ::scale_info::Type {
                    ::scale_info::Type::builder()
                        .path(
                            ::scale_info::Path::new(
                                "CallBuilder",
                                "delegator::delegator",
                            ),
                        )
                        .type_params(::alloc::vec::Vec::new())
                        .docs(
                            &[
                                "The ink! smart contract's call builder.",
                                "",
                                "Implements the underlying on-chain calling of the ink! smart contract",
                                "messages and trait implementations in a type safe way.",
                            ],
                        )
                        .composite(
                            ::scale_info::build::Fields::named()
                                .field(|f| {
                                    f
                                        .ty::<AccountId>()
                                        .name("account_id")
                                        .type_name("AccountId")
                                        .docs(&[])
                                }),
                        )
                }
            }
        };
        const _: () = {
            impl ::ink::storage::traits::StorageLayout for CallBuilder {
                fn layout(
                    __key: &::ink::primitives::Key,
                ) -> ::ink::metadata::layout::Layout {
                    ::ink::metadata::layout::Layout::Struct(
                        ::ink::metadata::layout::StructLayout::new(
                            "CallBuilder",
                            [
                                ::ink::metadata::layout::FieldLayout::new(
                                    "account_id",
                                    <AccountId as ::ink::storage::traits::StorageLayout>::layout(
                                        __key,
                                    ),
                                ),
                            ],
                        ),
                    )
                }
            }
        };
        const _: () = {
            impl ::ink::codegen::ContractCallBuilder for Delegator {
                type Type = CallBuilder;
            }
            impl ::ink::traits::ContractEnv for CallBuilder {
                type Env = <Delegator as ::ink::traits::ContractEnv>::Env;
            }
        };
        impl ::ink::env::call::FromAccountId<Environment> for CallBuilder {
            #[inline]
            fn from_account_id(account_id: AccountId) -> Self {
                Self { account_id }
            }
        }
        impl ::ink::ToAccountId<Environment> for CallBuilder {
            #[inline]
            fn to_account_id(&self) -> AccountId {
                <AccountId as ::core::clone::Clone>::clone(&self.account_id)
            }
        }
        impl CallBuilder {
            /// Returns the `accumulator` value.
            #[allow(clippy::type_complexity)]
            #[inline]
            pub fn get(
                &self,
                __ink_binding_0: i32,
            ) -> ::ink::env::call::CallBuilder<
                Environment,
                ::ink::env::call::utils::Set<::ink::env::call::Call<Environment>>,
                ::ink::env::call::utils::Set<
                    ::ink::env::call::ExecutionInput<
                        ::ink::env::call::utils::ArgumentList<
                            ::ink::env::call::utils::Argument<i32>,
                            ::ink::env::call::utils::EmptyArgumentList,
                        >,
                    >,
                >,
                ::ink::env::call::utils::Set<::ink::env::call::utils::ReturnType<i32>>,
            > {
                ::ink::env::call::build_call::<Environment>()
                    .call_type(
                        ::ink::env::call::Call::new()
                            .callee(::ink::ToAccountId::to_account_id(self)),
                    )
                    .exec_input(
                        ::ink::env::call::ExecutionInput::new(
                            ::ink::env::call::Selector::new([
                                0x2F_u8,
                                0x86_u8,
                                0x5B_u8,
                                0xD9_u8,
                            ]),
                        )
                            .push_arg(__ink_binding_0),
                    )
                    .returns::<i32>()
            }
            /// Returns the `accumulator` value.
            #[allow(clippy::type_complexity)]
            #[inline]
            pub fn net(
                &self,
                __ink_binding_0: i32,
            ) -> ::ink::env::call::CallBuilder<
                Environment,
                ::ink::env::call::utils::Set<::ink::env::call::Call<Environment>>,
                ::ink::env::call::utils::Set<
                    ::ink::env::call::ExecutionInput<
                        ::ink::env::call::utils::ArgumentList<
                            ::ink::env::call::utils::Argument<i32>,
                            ::ink::env::call::utils::EmptyArgumentList,
                        >,
                    >,
                >,
                ::ink::env::call::utils::Set<::ink::env::call::utils::ReturnType<i32>>,
            > {
                ::ink::env::call::build_call::<Environment>()
                    .call_type(
                        ::ink::env::call::Call::new()
                            .callee(::ink::ToAccountId::to_account_id(self)),
                    )
                    .exec_input(
                        ::ink::env::call::ExecutionInput::new(
                            ::ink::env::call::Selector::new([
                                0x74_u8,
                                0xA1_u8,
                                0x82_u8,
                                0x49_u8,
                            ]),
                        )
                            .push_arg(__ink_binding_0),
                    )
                    .returns::<i32>()
            }
            /// Returns the `accumulator` value 2.
            #[allow(clippy::type_complexity)]
            #[inline]
            pub fn blabla(
                &self,
            ) -> ::ink::env::call::CallBuilder<
                Environment,
                ::ink::env::call::utils::Set<::ink::env::call::Call<Environment>>,
                ::ink::env::call::utils::Set<
                    ::ink::env::call::ExecutionInput<
                        ::ink::env::call::utils::EmptyArgumentList,
                    >,
                >,
                ::ink::env::call::utils::Set<::ink::env::call::utils::ReturnType<i32>>,
            > {
                ::ink::env::call::build_call::<Environment>()
                    .call_type(
                        ::ink::env::call::Call::new()
                            .callee(::ink::ToAccountId::to_account_id(self)),
                    )
                    .exec_input(
                        ::ink::env::call::ExecutionInput::new(
                            ::ink::env::call::Selector::new([
                                0x6A_u8,
                                0x77_u8,
                                0xFD_u8,
                                0xD2_u8,
                            ]),
                        ),
                    )
                    .returns::<i32>()
            }
        }
    };

    /// Delegates calls to an `adder` or `subber` contract to mutate
    /// a value in an `accumulator` contract.
    ///
    /// # Note
    ///
    /// In order to instantiate the `delegator` smart contract we first
    /// have to manually put the code of the `accumulator`, `adder`
    /// and `subber` smart contracts, receive their code hashes from
    /// the signalled events and put their code hash into our
    /// `delegator` smart contract.
    ///
    /// The `AccumulatorRef`, `AdderRef` and `SubberRef` are smart contract
    /// reference types that have been automatically generated by ink!.
    pub struct DelegatorRef {
        inner: <Delegator as ::ink::codegen::ContractCallBuilder>::Type,
    }

    #[automatically_derived]
    impl ::core::fmt::Debug for DelegatorRef {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field1_finish(
                f,
                "DelegatorRef",
                "inner",
                &&self.inner,
            )
        }
    }

    #[allow(deprecated)]
    const _: () = {
        #[automatically_derived]
        impl ::scale::Encode for DelegatorRef {
            fn encode_to<__CodecOutputEdqy: ::scale::Output + ?::core::marker::Sized>(
                &self,
                __codec_dest_edqy: &mut __CodecOutputEdqy,
            ) {
                ::scale::Encode::encode_to(&&self.inner, __codec_dest_edqy)
            }
            fn encode(&self) -> ::scale::alloc::vec::Vec<::core::primitive::u8> {
                ::scale::Encode::encode(&&self.inner)
            }
            fn using_encoded<R, F: ::core::ops::FnOnce(&[::core::primitive::u8]) -> R>(
                &self,
                f: F,
            ) -> R {
                ::scale::Encode::using_encoded(&&self.inner, f)
            }
        }
        #[automatically_derived]
        impl ::scale::EncodeLike for DelegatorRef {}
    };
    #[allow(deprecated)]
    const _: () = {
        #[automatically_derived]
        impl ::scale::Decode for DelegatorRef {
            fn decode<__CodecInputEdqy: ::scale::Input>(
                __codec_input_edqy: &mut __CodecInputEdqy,
            ) -> ::core::result::Result<Self, ::scale::Error> {
                ::core::result::Result::Ok(DelegatorRef {
                    inner: {
                        let __codec_res_edqy = <<Delegator as ::ink::codegen::ContractCallBuilder>::Type as ::scale::Decode>::decode(
                            __codec_input_edqy,
                        );
                        match __codec_res_edqy {
                            ::core::result::Result::Err(e) => {
                                return ::core::result::Result::Err(
                                    e.chain("Could not decode `DelegatorRef::inner`"),
                                );
                            }
                            ::core::result::Result::Ok(__codec_res_edqy) => {
                                __codec_res_edqy
                            }
                        }
                    },
                })
            }
        }
    };

    #[automatically_derived]
    impl ::core::hash::Hash for DelegatorRef {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            ::core::hash::Hash::hash(&self.inner, state)
        }
    }

    impl ::core::marker::StructuralPartialEq for DelegatorRef {}

    #[automatically_derived]
    impl ::core::cmp::PartialEq for DelegatorRef {
        #[inline]
        fn eq(&self, other: &DelegatorRef) -> bool {
            self.inner == other.inner
        }
    }

    impl ::core::marker::StructuralEq for DelegatorRef {}

    #[automatically_derived]
    impl ::core::cmp::Eq for DelegatorRef {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<
                <Delegator as ::ink::codegen::ContractCallBuilder>::Type,
            >;
        }
    }

    #[automatically_derived]
    impl ::core::clone::Clone for DelegatorRef {
        #[inline]
        fn clone(&self) -> DelegatorRef {
            DelegatorRef {
                inner: ::core::clone::Clone::clone(&self.inner),
            }
        }
    }

    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        impl ::scale_info::TypeInfo for DelegatorRef {
            type Identity = Self;
            fn type_info() -> ::scale_info::Type {
                ::scale_info::Type::builder()
                    .path(
                        ::scale_info::Path::new("DelegatorRef", "delegator::delegator"),
                    )
                    .type_params(::alloc::vec::Vec::new())
                    .docs(
                        &[
                            "Delegates calls to an `adder` or `subber` contract to mutate",
                            "a value in an `accumulator` contract.",
                            "",
                            "# Note",
                            "",
                            "In order to instantiate the `delegator` smart contract we first",
                            "have to manually put the code of the `accumulator`, `adder`",
                            "and `subber` smart contracts, receive their code hashes from",
                            "the signalled events and put their code hash into our",
                            "`delegator` smart contract.",
                            "",
                            "The `AccumulatorRef`, `AdderRef` and `SubberRef` are smart contract",
                            "reference types that have been automatically generated by ink!.",
                        ],
                    )
                    .composite(
                        ::scale_info::build::Fields::named()
                            .field(|f| {
                                f
                                    .ty::<
                                        <Delegator as ::ink::codegen::ContractCallBuilder>::Type,
                                    >()
                                    .name("inner")
                                    .type_name(
                                        "<Delegator as::ink::codegen::ContractCallBuilder>::Type",
                                    )
                                    .docs(&[])
                            }),
                    )
            }
        }
    };
    const _: () = {
        impl ::ink::storage::traits::StorageLayout for DelegatorRef {
            fn layout(
                __key: &::ink::primitives::Key,
            ) -> ::ink::metadata::layout::Layout {
                ::ink::metadata::layout::Layout::Struct(
                    ::ink::metadata::layout::StructLayout::new(
                        "DelegatorRef",
                        [
                            ::ink::metadata::layout::FieldLayout::new(
                                "inner",
                                <<Delegator as ::ink::codegen::ContractCallBuilder>::Type as ::ink::storage::traits::StorageLayout>::layout(
                                    __key,
                                ),
                            ),
                        ],
                    ),
                )
            }
        }
    };
    const _: () = {
        impl ::ink::traits::ContractReference for Delegator {
            type Type = DelegatorRef;
        }
        impl ::ink::traits::ContractEnv for DelegatorRef {
            type Env = <Delegator as ::ink::traits::ContractEnv>::Env;
        }
    };

    impl DelegatorRef {
        /// Instantiate a `delegator` contract with the given sub-contract codes.
        #[inline]
        #[allow(clippy::type_complexity)]
        pub fn new(
            __ink_binding_0: i32,
            __ink_binding_1: u32,
            __ink_binding_2: Hash,
            __ink_binding_3: Hash,
            __ink_binding_4: Hash,
        ) -> ::ink::env::call::CreateBuilder<
            Environment,
            ::ink::env::call::utils::Unset<Hash>,
            ::ink::env::call::utils::Unset<u64>,
            ::ink::env::call::utils::Unset<Balance>,
            ::ink::env::call::utils::Set<
                ::ink::env::call::ExecutionInput<
                    ::ink::env::call::utils::ArgumentList<
                        ::ink::env::call::utils::Argument<Hash>,
                        ::ink::env::call::utils::ArgumentList<
                            ::ink::env::call::utils::Argument<Hash>,
                            ::ink::env::call::utils::ArgumentList<
                                ::ink::env::call::utils::Argument<Hash>,
                                ::ink::env::call::utils::ArgumentList<
                                    ::ink::env::call::utils::Argument<u32>,
                                    ::ink::env::call::utils::ArgumentList<
                                        ::ink::env::call::utils::Argument<i32>,
                                        ::ink::env::call::utils::EmptyArgumentList,
                                    >,
                                >,
                            >,
                        >,
                    >,
                >,
            >,
            ::ink::env::call::utils::Unset<::ink::env::call::state::Salt>,
            Self,
        > {
            ::ink::env::call::build_create::<Environment, Self>()
                .exec_input(
                    ::ink::env::call::ExecutionInput::new(
                        ::ink::env::call::Selector::new([
                            0x9B_u8,
                            0xAE_u8,
                            0x9D_u8,
                            0x5E_u8,
                        ]),
                    )
                        .push_arg(__ink_binding_0)
                        .push_arg(__ink_binding_1)
                        .push_arg(__ink_binding_2)
                        .push_arg(__ink_binding_3)
                        .push_arg(__ink_binding_4),
                )
        }
        /// Returns the `accumulator` value.
        #[inline]
        pub fn get(&self, _a: i32) -> i32 {
            <Self as ::ink::codegen::TraitCallBuilder>::call(self)
                .get(_a)
                .fire()
                .unwrap_or_else(|error| ::core::panicking::panic_fmt(
                    ::core::fmt::Arguments::new_v1(
                        &["encountered error while calling ", "::", ": "],
                        &match (&"Delegator", &"get", &error) {
                            args => {
                                [
                                    ::core::fmt::ArgumentV1::new_display(args.0),
                                    ::core::fmt::ArgumentV1::new_display(args.1),
                                    ::core::fmt::ArgumentV1::new_debug(args.2),
                                ]
                            }
                        },
                    ),
                ))
        }
        /// Returns the `accumulator` value.
        #[inline]
        pub fn net(&self, _a: i32) -> i32 {
            <Self as ::ink::codegen::TraitCallBuilder>::call(self)
                .net(_a)
                .fire()
                .unwrap_or_else(|error| ::core::panicking::panic_fmt(
                    ::core::fmt::Arguments::new_v1(
                        &["encountered error while calling ", "::", ": "],
                        &match (&"Delegator", &"net", &error) {
                            args => {
                                [
                                    ::core::fmt::ArgumentV1::new_display(args.0),
                                    ::core::fmt::ArgumentV1::new_display(args.1),
                                    ::core::fmt::ArgumentV1::new_debug(args.2),
                                ]
                            }
                        },
                    ),
                ))
        }
        /// Returns the `accumulator` value 2.
        #[inline]
        pub fn blabla(&self) -> i32 {
            <Self as ::ink::codegen::TraitCallBuilder>::call(self)
                .blabla()
                .fire()
                .unwrap_or_else(|error| ::core::panicking::panic_fmt(
                    ::core::fmt::Arguments::new_v1(
                        &["encountered error while calling ", "::", ": "],
                        &match (&"Delegator", &"blabla", &error) {
                            args => {
                                [
                                    ::core::fmt::ArgumentV1::new_display(args.0),
                                    ::core::fmt::ArgumentV1::new_display(args.1),
                                    ::core::fmt::ArgumentV1::new_debug(args.2),
                                ]
                            }
                        },
                    ),
                ))
        }
    }

    const _: () = {
        impl ::ink::codegen::TraitCallBuilder for DelegatorRef {
            type Builder = <Delegator as ::ink::codegen::ContractCallBuilder>::Type;
            #[inline]
            fn call(&self) -> &Self::Builder {
                &self.inner
            }
            #[inline]
            fn call_mut(&mut self) -> &mut Self::Builder {
                &mut self.inner
            }
        }
    };

    impl ::ink::env::call::FromAccountId<Environment> for DelegatorRef {
        #[inline]
        fn from_account_id(account_id: AccountId) -> Self {
            Self {
                inner: <<Delegator as ::ink::codegen::ContractCallBuilder>::Type as ::ink::env::call::FromAccountId<
                    Environment,
                >>::from_account_id(account_id),
            }
        }
    }

    impl ::ink::ToAccountId<Environment> for DelegatorRef {
        #[inline]
        fn to_account_id(&self) -> AccountId {
            <<Delegator as ::ink::codegen::ContractCallBuilder>::Type as ::ink::ToAccountId<
                Environment,
            >>::to_account_id(&self.inner)
        }
    }

    #[cfg(feature = "std")]
    #[cfg(not(feature = "ink-as-dependency"))]
    const _: () = {
        #[no_mangle]
        pub fn __ink_generate_metadata() -> ::ink::metadata::InkProject {
            let layout = ::ink::metadata::layout::Layout::Root(
                ::ink::metadata::layout::RootLayout::new(
                    <::ink::metadata::layout::LayoutKey as ::core::convert::From<
                        ::ink::primitives::Key,
                    >>::from(<Delegator as ::ink::storage::traits::StorageKey>::KEY),
                    <Delegator as ::ink::storage::traits::StorageLayout>::layout(
                        &<Delegator as ::ink::storage::traits::StorageKey>::KEY,
                    ),
                ),
            );
            ::ink::metadata::layout::ValidateLayout::validate(&layout)
                .unwrap_or_else(|error| {
                    ::core::panicking::panic_fmt(
                        ::core::fmt::Arguments::new_v1(
                            &["metadata ink! generation failed: "],
                            &[::core::fmt::ArgumentV1::new_display(&error)],
                        ),
                    )
                });
            ::ink::metadata::InkProject::new(
                layout,
                ::ink::metadata::ContractSpec::new()
                    .constructors([
                        ::ink::metadata::ConstructorSpec::from_label("new")
                            .selector([0x9B_u8, 0xAE_u8, 0x9D_u8, 0x5E_u8])
                            .args([
                                ::ink::metadata::MessageParamSpec::new("init_value")
                                    .of_type(
                                        ::ink::metadata::TypeSpec::with_name_segs::<
                                            i32,
                                            _,
                                        >(
                                            ::core::iter::IntoIterator::into_iter(["i32"])
                                                .map(::core::convert::AsRef::as_ref),
                                        ),
                                    )
                                    .done(),
                                ::ink::metadata::MessageParamSpec::new("version")
                                    .of_type(
                                        ::ink::metadata::TypeSpec::with_name_segs::<
                                            u32,
                                            _,
                                        >(
                                            ::core::iter::IntoIterator::into_iter(["u32"])
                                                .map(::core::convert::AsRef::as_ref),
                                        ),
                                    )
                                    .done(),
                                ::ink::metadata::MessageParamSpec::new(
                                    "accumulator_code_hash",
                                )
                                    .of_type(
                                        ::ink::metadata::TypeSpec::with_name_segs::<
                                            Hash,
                                            _,
                                        >(
                                            ::core::iter::IntoIterator::into_iter(["Hash"])
                                                .map(::core::convert::AsRef::as_ref),
                                        ),
                                    )
                                    .done(),
                                ::ink::metadata::MessageParamSpec::new("_adder_code_hash")
                                    .of_type(
                                        ::ink::metadata::TypeSpec::with_name_segs::<
                                            Hash,
                                            _,
                                        >(
                                            ::core::iter::IntoIterator::into_iter(["Hash"])
                                                .map(::core::convert::AsRef::as_ref),
                                        ),
                                    )
                                    .done(),
                                ::ink::metadata::MessageParamSpec::new("_subber_code_hash")
                                    .of_type(
                                        ::ink::metadata::TypeSpec::with_name_segs::<
                                            Hash,
                                            _,
                                        >(
                                            ::core::iter::IntoIterator::into_iter(["Hash"])
                                                .map(::core::convert::AsRef::as_ref),
                                        ),
                                    )
                                    .done(),
                            ])
                            .payable(false)
                            .docs([
                                " Instantiate a `delegator` contract with the given sub-contract codes.",
                            ])
                            .done(),
                    ])
                    .messages([
                        ::ink::metadata::MessageSpec::from_label("get")
                            .selector([0x2F_u8, 0x86_u8, 0x5B_u8, 0xD9_u8])
                            .args([
                                ::ink::metadata::MessageParamSpec::new("_a")
                                    .of_type(
                                        ::ink::metadata::TypeSpec::with_name_segs::<
                                            i32,
                                            _,
                                        >(
                                            ::core::iter::IntoIterator::into_iter(["i32"])
                                                .map(::core::convert::AsRef::as_ref),
                                        ),
                                    )
                                    .done(),
                            ])
                            .returns(
                                ::ink::metadata::ReturnTypeSpec::new(
                                    ::ink::metadata::TypeSpec::with_name_segs::<
                                        i32,
                                        _,
                                    >(
                                        ::core::iter::IntoIterator::into_iter(["i32"])
                                            .map(::core::convert::AsRef::as_ref),
                                    ),
                                ),
                            )
                            .mutates(false)
                            .payable(false)
                            .docs([" Returns the `accumulator` value."])
                            .done(),
                        ::ink::metadata::MessageSpec::from_label("net")
                            .selector([0x74_u8, 0xA1_u8, 0x82_u8, 0x49_u8])
                            .args([
                                ::ink::metadata::MessageParamSpec::new("_a")
                                    .of_type(
                                        ::ink::metadata::TypeSpec::with_name_segs::<
                                            i32,
                                            _,
                                        >(
                                            ::core::iter::IntoIterator::into_iter(["i32"])
                                                .map(::core::convert::AsRef::as_ref),
                                        ),
                                    )
                                    .done(),
                            ])
                            .returns(
                                ::ink::metadata::ReturnTypeSpec::new(
                                    ::ink::metadata::TypeSpec::with_name_segs::<
                                        i32,
                                        _,
                                    >(
                                        ::core::iter::IntoIterator::into_iter(["i32"])
                                            .map(::core::convert::AsRef::as_ref),
                                    ),
                                ),
                            )
                            .mutates(false)
                            .payable(false)
                            .docs([" Returns the `accumulator` value."])
                            .done(),
                        ::ink::metadata::MessageSpec::from_label("blabla")
                            .selector([0x6A_u8, 0x77_u8, 0xFD_u8, 0xD2_u8])
                            .args([])
                            .returns(
                                ::ink::metadata::ReturnTypeSpec::new(
                                    ::ink::metadata::TypeSpec::with_name_segs::<
                                        i32,
                                        _,
                                    >(
                                        ::core::iter::IntoIterator::into_iter(["i32"])
                                            .map(::core::convert::AsRef::as_ref),
                                    ),
                                ),
                            )
                            .mutates(false)
                            .payable(false)
                            .docs([" Returns the `accumulator` value 2."])
                            .done(),
                    ])
                    .events([])
                    .docs([])
                    .done(),
            )
        }
    };

    use accumulator::AccumulatorRef;
    use adder::AdderRef;
    use subber::SubberRef;

    /// Specifies the state of the `delegator` contract.
    ///
    /// In `Adder` state the `delegator` contract will delegate to the `Adder` contract
    /// and in `Subber` state will delegate to the `Subber` contract.
    ///
    /// The initial state is `Adder`.
    pub enum Which {
        Adder,
        Subber,
    }

    const _: () = {
        impl ::ink::storage::traits::StorageLayout for Which {
            fn layout(
                __key: &::ink::primitives::Key,
            ) -> ::ink::metadata::layout::Layout {
                ::ink::metadata::layout::Layout::Enum(
                    ::ink::metadata::layout::EnumLayout::new(
                        "Which",
                        ::ink::metadata::layout::LayoutKey::from(__key),
                        [
                            {
                                (
                                    ::ink::metadata::layout::Discriminant::from(0usize),
                                    ::ink::metadata::layout::StructLayout::new("Adder", []),
                                )
                            },
                            {
                                (
                                    ::ink::metadata::layout::Discriminant::from(1usize),
                                    ::ink::metadata::layout::StructLayout::new("Subber", []),
                                )
                            },
                        ],
                    ),
                )
            }
        }
    };
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        impl ::scale_info::TypeInfo for Which {
            type Identity = Self;
            fn type_info() -> ::scale_info::Type {
                ::scale_info::Type::builder()
                    .path(::scale_info::Path::new("Which", "delegator::delegator"))
                    .type_params(::alloc::vec::Vec::new())
                    .docs(
                        &[
                            "Specifies the state of the `delegator` contract.",
                            "",
                            "In `Adder` state the `delegator` contract will delegate to the `Adder` contract",
                            "and in `Subber` state will delegate to the `Subber` contract.",
                            "",
                            "The initial state is `Adder`.",
                        ],
                    )
                    .variant(
                        ::scale_info::build::Variants::new()
                            .variant(
                                "Adder",
                                |v| v.index(0usize as ::core::primitive::u8).docs(&[]),
                            )
                            .variant(
                                "Subber",
                                |v| v.index(1usize as ::core::primitive::u8).docs(&[]),
                            ),
                    )
            }
        }
    };

    #[automatically_derived]
    impl ::core::fmt::Debug for Which {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match self {
                Which::Adder => ::core::fmt::Formatter::write_str(f, "Adder"),
                Which::Subber => ::core::fmt::Formatter::write_str(f, "Subber"),
            }
        }
    }

    #[automatically_derived]
    impl ::core::marker::Copy for Which {}

    #[automatically_derived]
    impl ::core::clone::Clone for Which {
        #[inline]
        fn clone(&self) -> Which {
            *self
        }
    }

    impl ::core::marker::StructuralPartialEq for Which {}

    #[automatically_derived]
    impl ::core::cmp::PartialEq for Which {
        #[inline]
        fn eq(&self, other: &Which) -> bool {
            let __self_tag = ::core::intrinsics::discriminant_value(self);
            let __arg1_tag = ::core::intrinsics::discriminant_value(other);
            __self_tag == __arg1_tag
        }
    }

    impl ::core::marker::StructuralEq for Which {}

    #[automatically_derived]
    impl ::core::cmp::Eq for Which {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {}
    }

    #[allow(deprecated)]
    const _: () = {
        #[automatically_derived]
        impl ::scale::Decode for Which {
            fn decode<__CodecInputEdqy: ::scale::Input>(
                __codec_input_edqy: &mut __CodecInputEdqy,
            ) -> ::core::result::Result<Self, ::scale::Error> {
                match __codec_input_edqy
                    .read_byte()
                    .map_err(|e| {
                        e.chain("Could not decode `Which`, failed to read variant byte")
                    })?
                {
                    __codec_x_edqy if __codec_x_edqy
                        == 0usize as ::core::primitive::u8 => {
                        ::core::result::Result::Ok(Which::Adder)
                    }
                    __codec_x_edqy if __codec_x_edqy
                        == 1usize as ::core::primitive::u8 => {
                        ::core::result::Result::Ok(Which::Subber)
                    }
                    _ => {
                        ::core::result::Result::Err(
                            <_ as ::core::convert::Into<
                                _,
                            >>::into("Could not decode `Which`, variant doesn't exist"),
                        )
                    }
                }
            }
        }
    };
    #[allow(deprecated)]
    const _: () = {
        #[automatically_derived]
        impl ::scale::Encode for Which {
            fn encode_to<__CodecOutputEdqy: ::scale::Output + ?::core::marker::Sized>(
                &self,
                __codec_dest_edqy: &mut __CodecOutputEdqy,
            ) {
                match *self {
                    Which::Adder => {
                        __codec_dest_edqy.push_byte(0usize as ::core::primitive::u8);
                    }
                    Which::Subber => {
                        __codec_dest_edqy.push_byte(1usize as ::core::primitive::u8);
                    }
                    _ => {}
                }
            }
        }
        #[automatically_derived]
        impl ::scale::EncodeLike for Which {}
    };
}
